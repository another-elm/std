/*

import Elm.Kernel.Utils exposing (chr, Tuple2, Tuple3)

*/

// STRINGS

const _Parser_isSubString = F5(function (smallString, offset, row, col, bigString) {
  const smallLength = smallString.length;
  let isGood = offset + smallLength <= bigString.length;

  for (let i = 0; isGood && i < smallLength; ) {
    const code = bigString.charCodeAt(offset);
    isGood =
      smallString[i++] === bigString[offset++] &&
      (code === 0x000a /* \n */
        ? (row++, (col = 1))
        : (col++, (code & 0xf800) === 0xd800 ? smallString[i++] === bigString[offset++] : 1));
  }

  return __Utils_Tuple3(isGood ? offset : -1, row, col);
});

// CHARS

const _Parser_isSubChar = F3(function (predicate, offset, string) {
  return string.length <= offset
    ? -1
    : (string.charCodeAt(offset) & 0xf800) === 0xd800
    ? predicate(__Utils_chr(string.substr(offset, 2)))
      ? offset + 2
      : -1
    : predicate(__Utils_chr(string[offset]))
    ? string[offset] === "\n"
      ? -2
      : offset + 1
    : -1;
});

const _Parser_isAsciiCode = F3(function (code, offset, string) {
  return string.charCodeAt(offset) === code;
});

// NUMBERS

const _Parser_chompBase10 = F2(function (offset, string) {
  for (; offset < string.length; offset++) {
    const code = string.charCodeAt(offset);
    if (code < 0x30 || code > 0x39) {
      return offset;
    }
  }

  return offset;
});

const _Parser_consumeBase = F3(function (base, offset, string) {
  for (var total = 0; offset < string.length; offset++) {
    const digit = string.charCodeAt(offset) - 0x30;
    if (digit < 0 || base <= digit) break;
    total = base * total + digit;
  }

  return __Utils_Tuple2(offset, total);
});

const _Parser_consumeBase16 = F2(function (offset, string) {
  for (var total = 0; offset < string.length; offset++) {
    const code = string.charCodeAt(offset);
    if (code >= 0x30 && code <= 0x39) {
      total = 16 * total + code - 0x30;
    } else if (code >= 0x41 && code <= 0x46) {
      total = 16 * total + code - 55;
    } else if (code >= 0x61 && code <= 0x66) {
      total = 16 * total + code - 87;
    } else {
      break;
    }
  }

  return __Utils_Tuple2(offset, total);
});

// FIND STRING

const _Parser_findSubString = F5(function (smallString, offset, row, col, bigString) {
  const newOffset = bigString.indexOf(smallString, offset);
  const target = newOffset < 0 ? bigString.length : newOffset + smallString.length;

  while (offset < target) {
    const code = bigString.charCodeAt(offset++);
    code === 0x000a /* \n */ ? ((col = 1), row++) : (col++, (code & 0xf800) === 0xd800 && offset++);
  }

  return __Utils_Tuple3(newOffset, row, col);
});

/* ESLINT GLOBAL VARIABLES
 *
 * Do not edit below this line as it is generated by tests/generate-globals.py
 */

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "_Parser_.*" }] */

/* global __Utils_chr, __Utils_Tuple2, __Utils_Tuple3 */
